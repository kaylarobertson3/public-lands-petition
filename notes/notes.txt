
Page 1: petition page
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    - introduces your petition.
    - input fields for first last name field (using canvas) for signature
        - when mouse is down, record position in var.
        draw a line from old x and old y to new x and y. Then overwrite old with new positions. when mouse goes up, stop doing it. Similar to drag and drop square exercise.
        ??????????
        Draw little bits each time on mouse move event.
    - On 'Submit' click: submit first name and last name and image data from signature.
        - Canvases have a method called toDataURL();
        - Save in DB as 'text' because it will be long
        - Form element 'hidden' for something????
        -  put the data from canvas into input type hidden before all of the data gets sent to the server.

        <form method="POST">
            <input type="text">
            <input type="text">
            <input type="hidden">
            <button>submit</button>
        </form>
        <canvas></canvas>

        on server: req.body.firstname, last, sig.

Page 2: Thank you page
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- Say thank you
- Have a link to page 3.
- See all 10 signers
- Prevent them from signing again
    - If they go back to localhost 8080,
    - If they have been redirected to thank you page
    - On page 1, check if they have cookie. if not, let them sign. if they do, send them to thank you page.

Page 2: Signers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- get request to signers page
- Select first, last from signatures
- pass it to a handlebars template that generates
- treating signature photo as private info. can show to user it belongs to, but no one else

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
TIPS: Using aliases in the command links
- cd - takes you to root folder
-


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Cookies
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- req.session - a new property on req. object
- set a cookie this way: req.session.signatureId = id;
    - This way it's saved in a session




////// more notes
Petition, Part I
The pg module communicates with the Postgres databases.
What is pg? pg makes a connection to Postgres, and it's able to send queries to Postgres and receives responses. It handles that communication for us.
To make a query, we need a client. A clien is an object that can communicate with our database (send queries and receive answers). The best way to create a client is with the Client constructor:
    var pg = require('pg');

    var client = new pg.Client('postgres://spicedling:password@localhost:5432/cities');

    client.connect(function(err) {
        if (err) {
            console.log(err);
        } else {
            client.query('SELECT * FROM cities', function(err, results) {
            console.log(results.rows);
            client.end();
            });
        }
    });
Note: 5432 is the default port that the database listens on
A Postgres URL looks as following: 'postgres://spicedling:password@localhost:5432/cities', with spicedling being the password, 5432 being the port it's listening on, and cities being the name of the database.
Postgres, however, can only handle a limited number of connections at a time. So you can't have 100+ connections, or else Postgres will slow down and eventually become unusable. Postgres can only handle so many connections all at once.
To get around this, we use connection pooling. Essentially, you keep a pool of 10 connections instead of having 100 connections running at once. The pool software manages which connection is serviced when.
We will be using spicedPg. SpicedPg takes care of pooling and connections for us:
    var spicedPg = require('spiced-pg');

    var db = spicedPg('postgres:spicedling:password@localhost:5432/cities');

    db.query('SELECT * FROM cities').then(function(results) {
        console.log(results.rows);
    }).catch(function(err) {
        console.log(err);
    });
When you do this, you get a massive object as a response to your query. The most interesting is that you get a property row that contains everything in the table as a result. The result is an array of objects.
You can use callbacks instead of promises, if wanted:
    var spicedPg = require('spiced-pg');

    var db = spicedPg('postgres:spicedling:password@localhost:5432/cities');

    db.query('SELECT * FROM cities WHERE id = 1'), function(err, result) {
        if (!err) {
            console.log(results.rows);
            }
        }
    });
SQL injections
---
Sometimes users will inject input into our program that our code will interpret as executable code. For this reason we can never trust user input. We have to protect our code from people who would to inject code into our program to mess it up.
For example, if we have the following code, the user could enter DROP TABLE has user input, and our code would execute it:
    function findCity(name) {
      db.query("SELECT * FROM cities WHERE city = " + name, function((err, result) {
        if (!err) {
          console.log(result.rows);
        } // END if
      }))
    }

    berlin; DROP TABLE users;
To fix this:
    function findCity(name) {

      db.query(
      "SELECT * FROM cities WHERE city = $1 AND id = $2",
      [name, id],

      function((err, result) {
        if (!err) {
          console.log(result.rows);
        } // END if

      }))
    }
Or with promises:
    function findCity(name) {

      db.query(

      "SELECT * FROM cities WHERE city = $1 AND id = $2",
        [name, id].then(function(result) {

          console.log(result.rows)

        }).catch(function(err) {

          console.log(err);

        })

    }
Essentially, this forces user input to be added as a string to your code. This prevents our code from reading the user input as code to be executed.
organization
---
How to organize the petition project?
    var spicedPg = require('spiced-pg');

    var db = spicedPg('postgres:spicedling:password@localhost:5432/cities');

    function signPetition(first, last, signature) {
      db.query(`INSERT INTO signatures (first, last, signature))
                VALUES ($1, $2, $3)`)

    };

    exports.signPetition = signPetition;



    function findCity(name) {

      db.query(

      "SELECT * FROM cities WHERE city = $1 AND id = $2",
        [name, id].then(function(result) {
          console.log(result.rows)
        }).catch(function(err) {
          console.log(err);
        })

    }
The best way is to separate database queries and functions.
petition introduction
---
This project does not require any ajax. This will be an old school website, in that if the user clicks a link, it will serve up a new HTML site. The HTML site will be handled by the server, meaning we'll need to use Handlebars. Every page will need a main Handlebars file
intro page
The first page is the introduction page, and has the petition available for people to sign. There should be a field for the first name and last name, and an area for the user to sign. The area for the user to sign should be a canvas.
What's happening is when the mouse goes down, we record where the mouse goes down on the field. Store this in a variable. When the mouse moves we draw a line from the old (x, y) to the new (x, y) and then we overwrite the mouse's position with the new (x, y)
submit
When the user clicks submit, we'll submit three things to server: first name, last name, and the image data of the signature.
How to save image data?
Canvases have a method called toDataUrl.
    var c = document.querySelector("canvas");

    c.toDataUrl();
When we call toDataUrl(), we get a massive ugly string. It's a base64 encoded URL. We can show it back to the user by saving it in a src element of a <img> tag.
We'll have 3 fields, firstName, lastName, and signature. Make the style of the form "hidden" so users can't see it.
    <form method = "POST">

      <input type = "text"> <!- FIRST-NAME -->
      <input type = "text"> <!- LAST-NAME -->
      <input type = "hidden"> <!- SIGNATURE -->
      <button></button>

    </form>

    <canvas></canvas>
Tricky part is, we need to get the submission in before the data goes to the server.
request.body.firstName & request.body.lastName & request.body.signature.
If you want to guard against a user leaving the signature field blank, you could do:
    var signed = false;

    $canvas).on("mousedown", function() {
      signed = true;
    })
server
create a database just for this project.
We'll want a table called signatures. When a user submits a signature, we'll submit the user's data from this.
    CREATE TABLE signatures(
    id SERIAL PRIMARY KEY,
      first VARCHAR(300) NOT NULL,
      last VARCHAR(300) NOT NULL,
      signature text NOT NULL,
      created_at TIMESTAMP DEFAULT CURRENT-TIMESTAMP
    )
"NOT NULL" means the table will not accept any empty values. So the user must submit a first name, last name, and signature.
created_at TIMESTAMP DEFAULT CURRENT-TIMESTAMP is optional, but it records the time at which the data was submitted. Allows us to stalk our users!
insert
when a user submits the form, we need to insert the information to our database.
We'll need a GET route to get information from the petition; and another POST route to POST the information to the database. If the POST doesn't work, then we could res.render the introductory HTML page, and keep doing that until the user submits valid data.
"thank you" page
this is the page you see after signing the position. The page just says "thanks" for now.
It should have a link to our third page.
Once a user signs the petition once, we don't want to let them sign the petition again. After a user signs the petition and we submit the info to the database, we should set a cookie that flags them as a signer of the petition. If the user has that cookie. If they do, send them to the thank you page. If not, let them go to the main petition page.
third page
the third page shows everyone's name who's signed the position. We're only showing the first and last name.
For this project, we're going to treat the user's actual signature as private information. We're never going to display the user's signature as private, and we're not showcasing it anywhere.
This page should be a Handlebars template.
overview
1. index page
2. acquire middleware (express static, cookie-parser, body-parser)
3. create database (signatures SQL)
4. create routes (GET, POST)
   1. GET route for thank you page
   2. GET route for signers page
   3. GET route for intro page
   4. POST route for intro page
5. templates (intro page, thank you page, signers page)
6. Browser JS for canvas page (so we'll have one JS file in the public directory)

BCRYPT: ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~





PART 5: Edit your profile ~~~~~~~~~~~~~~~~~~~~~~~~~~
    -Do a query, with a join


    PSQL TIPS ~~~~~~~~~~~~~~~~~~~~~~~~~~
    - \dt (gives list of tables)
    - \du (shows users on computer)
    - \



    Vulnerability  ~~~~~~~~~~~~~~~~~~~~~~~~~~

    Eval is dangerous - converts string into javascript

    var a = 10;
    eval('console.log(a)');

    -Cross site scripting: getting a site to load a script from another script
        -handlebars is not vulnerable to this

        DO THIS:

            app.disable('x-powered-by');

            app.use(function(req,res,next) {
                res.setHeader('x-frame-options', 'deny');
                next();
            })

- Currently vulnerable to:
    -CSRF or XSRF - cross site request forgery.
        - when you set a cookie, the browser automatically send cookies by a domain with every request to that domain. if a logged in user goes to another site, the other site can do post requests. Only bad for post requests.

        - How to prevent: put an unguessable token/string in every request.


    TO DO: app.usecsrf

    in js post requests:

    : in render:
    csrfToken: req.csrfTOken()

    in html: something with the form
        - input type="hidden" name="_csrf" value="{{csrfToken}}">
